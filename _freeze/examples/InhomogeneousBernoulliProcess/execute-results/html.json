{
  "hash": "6ae3c39c4a81a043e38a479aa38c9366",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Inhomogeneous Bernoulli Process\n---\n\n_Application: conversion rate optimization when all groups share a common multiplicative time-varying effect._\n\nBased on @lindon2022anytimevalid.\n\nSuppose a new experimental unit $n$ is randomly assigned to one of $i \\in \\{1, 2, 3\\}$ experiment treatment groups at time $t$, with assignment probabilities $\\mathbf{\\rho} = [0.1, 0.3, 0.6]$, and a Bernoulli outcome is observed with probability $p_i(t) = \\exp(\\mu(t) + \\delta_{i})$, $\\mathbf{\\delta} = [\\log 0.2, \\log 0.3, \\log 0.4]$. The conditional probability that the next Bernoulli success comes from group $i$ is\n\n$$\n\\theta_i = \\frac{\\rho_i \\exp(\\delta_i)}{\\sum_{j=1}^d \\rho_j \\exp(\\delta_j)}.\n$$\n\nTherefore, the next Bernoulli success comes from a random group, $\\mathrm{Multinomial}(1, \\mathbf{\\theta})$ distributed, with $\\mathbf{\\theta} \\approx [0.05, 0.25, 0.68]$.\n\n::: {#data .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n\nrho = np.array([0.1, 0.3, 0.6])\ndelta = np.log([0.2, 0.3, 0.4])\ntheta = rho * np.exp(delta) / np.sum(rho * np.exp(delta))\nsize = 5250\nnp.random.seed(1)\nxs = np.random.multinomial(1, theta, size=size)\nprint(xs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0 0 1]\n [0 0 1]\n [0 0 1]\n ...\n [0 1 0]\n [0 1 0]\n [1 0 0]]\n```\n:::\n:::\n\n\nWe can test the hypothesis\n\n$$\n\\begin{align}\nH_0: \\delta_0 \\geq \\delta_1, \\delta_0 \\geq \\delta_2 \\\\\nH_1: \\delta_0 \\lt \\delta_1, \\delta_0 \\lt \\delta_2\n\\end{align}\n$$\n\nusing a Multinomial test with $\\mathbf{\\theta}_0 = \\mathbf{\\rho}$ and a list of inequalities for $\\mathbf{\\delta}$. To estimate confidence intervals for the contrasts, we may set a matrix of weights, with rows $[-1, 0, 1]$ for $\\delta_2 - \\delta_0$ and $[0, -1, 1]$ for $\\delta_2 - \\delta_1$:\n\n::: {#hypothesis .cell execution_count=3}\n``` {.python .cell-code}\nfrom savvi.multinomial import InhomogeneousBernoulliProcess\n\nalpha = 0.05\nhypothesis = lambda delta: [delta[0] >= delta[1], delta[0] >= delta[2]]\nweights = np.array([[-1, 0, 1], [0, -1, 1]])\nibp = InhomogeneousBernoulliProcess(alpha, rho, hypothesis, weights)\n```\n:::\n\n\nFor each new unit sample $n$, we run the test. If $p_n < u$, we have the option to stop running:\n\n::: {#cell-sequence .cell execution_count=4}\n``` {.python .cell-code}\nimport cvxpy as cp\n\nsolver = cp.CLARABEL\nsequence = ibp.batch(xs, solver=solver)\noptional_stop = next(s for s in sequence if s.p_value <= alpha)\nvars(optional_stop)\n```\n\n::: {#sequence .cell-output .cell-output-display execution_count=3}\n```\n{'n': 302,\n 'alpha': 0.05,\n 'conf_int': array([[ 9.38644932e-04,  1.77164771e+00],\n        [-1.57653154e-01,  6.47239250e-01]]),\n 'p_value': array([0.04923547]),\n 'theta_0': array([0.1, 0.3, 0.6]),\n 'alpha_0': array([10., 30., 60.]),\n 'counts': array([ 15,  82, 205]),\n 'odds': array(20.31056249),\n 'hypothesis': <function __main__.<lambda>(delta)>,\n 'weights': array([[-1,  0,  1],\n        [ 0, -1,  1]])}\n```\n:::\n:::\n\n\n::: {#cell-fig .cell execution_count=5}\n``` {.python .cell-code}\n%config InlineBackend.figure_formats = [\"svg\"]\n\nimport matplotlib.pyplot as plt\nfrom savvi.utils import plot\n\ncontrasts = ibp.weights @ delta\n_, ax1, _ = plot(sequence, contrasts)\nax1.set_ylim(-1, 2)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](InhomogeneousBernoulliProcess_files/figure-html/fig-output-1.svg){#fig}\n:::\n:::\n\n\n\n\n",
    "supporting": [
      "InhomogeneousBernoulliProcess_files"
    ],
    "filters": [],
    "includes": {}
  }
}